<!DOCTYPE html>
<html>
<head>
    <title>第十三章 多线程 - 邠心工作室</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
    <link href="css/main.css" rel="stylesheet" />
    <script src="Script/shCore.js" type="text/javascript"></script>
    <script src="Script/shBrushJava.js" type="text/javascript"></script>
    <link href="css/shCoreDefault.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <div class="div">
        <blockquote>
            多线程是Java中的并发机制，表示能够在同一时间内同时执行多个操作。在日常生活中，边上网边听歌就是一个多线程。随着CPU进入双核，甚至多核时代，多线程的优势越来越明显。Java本身就是一门支持多线程的语言，在Java中使用多线程是很方便的，同样也是很高效的。通过本章的学习，同学们应该能够完成如下几个目标。
            <ol>
                <li>了解什么是多线程。</li>
                <li>熟练掌握如何定义和使用多线程。</li>
                <li>了解多线程的生命周期。</li>
                <li>掌握多线程的调用的几个情况。</li>
                <li>了解多线程的同步问题。</li>
            </ol>
        </blockquote>
        <h3>13.1  多线程简介</h3>
        <p>多线程就好像日常生活中同时做几件事一样，例如早上起床，要烧水洗脸，在烧水时就可以刷牙，还可以边刷牙边看早间新闻，这样就同时做着烧水、刷牙、看电视三件事。多线程也是一样的，在同一时刻有可能在执行多个线程，这样能够更好地提高办事效率。</p>
        <p>在实际开发中也是在很多地方使用多线程的，例如在很多网站中，当用户注册后，系统一方面会通知用户已经注册成功，一方面向用户在注册时填写的Email中发送邮件。这里就需要使用多线程，如果使用的是单线程，系统就会向用户注册的Email中发送邮件后才显示用户注册成功，由于发送邮件可能需要很长的时间，从而影响整个注册进度。</p>
        <p>在前面的学习中，虽然没有使用多线程，但是同样使用到了线程的知识。在每一个程序中的main方法就是一个线程，它一般被称为主线程。在主线程中可以启动多个子线程来执行。</p>
        <h3>13.2  定义线程和创建线程对象</h3>
        <p>在上一小节中讲解了什么是多线程，在本节中就来讲解怎样来定义线程和如何创建线程对象。定义线程有两种方法，一种是继承Thread类，一种是实现Runnable接口，这两种方法是存在各自优缺点的。和定义线程对应的就是创建线程对象，也是有两种方法。在本节中就来学习使用这两种方法来定义线程，以及相对应的创建线程对象。</p>
        <h4>13.2.1  继承Thread类定义线程</h4>
        <p>定义一个线程可以通过继承Thread类来实现，这是一种相对简单的定义线程的方法。在Thread类中具有一个run方法，在定义的线程中需要重写这个方法。在重写的run方法中，可以定义该线程所要执行的语句。当线程启动时，run方法中的程序就成为一条独立的执行线程。</p>
        <p class="exap">【范例】示例代码是一个通过继承Thread类定义线程的程序。</p>
        <pre class="brush:java">public class XianCheng1 extends Thread
{
	public void run()
	{
		System.out.println("通过继承Thread定义线程");
	}
}
</pre>
        <p>该程序是无法运行的，因为没有main方法，也就是没有启动线程的方法。在该程序中创建了一个线程类继承于Thread类，并且在该类中重写了run方法，在其中定义了该线程的功能是显示一条语句。</p>
        <p class="error">注意：重写的run方法也是可以作为一般的方法来调用的，但是这种调用并不是作为一个线程出现的，它只是主线程中的一部分。同样，run方法也是可以被重载的，但是重载后的run方法不作为一个线程，也是主线程的一部分。</p>
        <p>讲解完定义线程后，就可以来学习如何创建线程对象。通过继承Thread类创建线程，是很容易创建线程对象的。在这种定义线程的方法中，创建线程对象和创建普通对象是一样的。下面是创建示例代码13-1中线程对象的代码。</p>
        <pre class="brush:java">XianCheng1 xc=new XianCheng1();</pre>
        <p>从创建线程对象的程序可以看出，创建线程对象的方法和创建普通对象的方法是一样的。但是这只是对于使用继承Thread类创建线程的方法来说的。</p>
        <h3>13.2.2  实现Runnable接口定义线程</h3>
        <p>定义线程除了通过继承Thread类来实现，还可以通过实现Runnable接口来实现。在Runnable接口中具有一个抽象的run方法，在实现Runnable接口时，需要实现该run方法。该run方法就会作为一个执行线程的方法。</p>
        <p class="exap">【范例】示例代码是一个通过实现Runnable接口定义线程的程序。</p>
        <pre class="brush:java">public class XianCheng2 implements Runnable
{
	public void run()
	{
		System.out.println("通过实现Runnable接口定义线程");
	}
}</pre>
        <p class="exap">1是通过继承Thread类定义线程，2是通过实现Runnable接口来定义线程。这两种方法中都需要定义一个run方法，不管该方法是通过重写父类方法，还是实现接口方法。run方法是一个线程的入口，是线程必须具有的。</p>
        <p>在使用通过实现Runnable接口定义的线程中，要想创建线程对象就不是很容易做到的。因为直接创建类对象，创建的并不是一个线程对象。要想创建线程对象，必须要借助Thread类。</p>
        <p>Thread类具有4个构造器，最常用的就是具有一个参数，该参数是实现Runnable接口类对象的构造器。创建线程对象的程序如下所示。</p>
        <pre class="brush:java">XianCheng2 xc = new XianCheng2();
Thread t = new Thread(xc);
</pre>
        <p>在该程序中，首先创建了一个实现Runnable接口的类对象，然后将该对象作为Thread类的参数，从而创建了一个线程对象。创建的类对象是可以作为多个Thread类构造器参数的，这样就创建了多个线程。这一点将在以后的学习中多次使用。</p>
        <h3>13.3  运行线程</h3>
        <p>在上一节中学习了如何定义线程，并且知道了如何创建线程对象。对这些都了解后就需要来学习如何运行线程。在本节中分为两个小节来讲解，先来学习如何启动线程，然后讲解如何运行多个线程。</p>
        <h4>13.3.1  启动线程</h4>
        <p>有些同学们会认为启动线程就是调用线程类中的run方法。例如下面代码所演示的。</p>
        <pre class="brush:java">class MyRunnable implements Runnable
{
	//定义一个run线程方法
	public void run()
	{
		System.out.println("这是一个错误的启动线程的程序");
	}
}
public class XianCheng3
{
	public static void main(String args[])
	{
		MyRunnable mr=new MyRunnable();
		mr.run();	//调用run方法
	}
}</pre>
        <p class="exap">从该程序可以看出，run方法是可以通过方法调用来执行的，但是这并不代表创建了一个新线程。这是一个错误的启动线程的方法。</p>
        <p>如果想正确地启动一个线程，需要调用线程对象的start方法，下面通过程序来演示如何正确的启动一个线程。</p>
        <pre class="brush:java">class MyRunnable implements Runnable
{
	//定义一个run线程方法
	public void run()
	{
		System.out.println("这是一个正确的启动线程的程序");
	}
}
public class XianCheng4
{
	public static void main(String args[])
	{
		MyRunnable mr=new MyRunnable();
		Thread t=new Thread(mr);
		t. start ();	//启动线程
	}
}</pre>
        <p class="exap">【代码解析】第一次看到该程序时，同学们可能会感到有些奇怪，为什么调用的是start方法，而执行的是run方法，这就是Java对多线程的设计。在调用start方法后，就启动了线程，该线程是和main方法并列执行的线程。这样该程序就变为一个多线程程序。</p>
        <p class="error">注意：线程只能被启动一次，也就是只能调用一次start方法。当多次启动线程，也就是多次调用start方法时，就会发生异常。</p>
        <h4>13.3.2  同时运行多个线程</h4>
        <p>学习了如何启动线程，接下来就来学习如何同时运行多个线程。首先通过示例代码来看一下如何同时运行多个线程。</p>
        <pre class="brush:java">public static void main(String args[])
{
	MyRunnable1 mr1 = new MyRunnable1();
	MyRunnable2 mr2 = new MyRunnable2();
	Thread t1 = new Thread(mr1);
	Thread t2 = new Thread(mr2);
	t1.start();	//启动第一个线程
	t2.start();	//启动第二个线程
}</pre>
        <p class="exap">【代码解析】在示例代码13-6中首先定义了两个实现Runnable接口的类，在两个类中都定义了run方法，显示多个不同的符号。从运行结果中可以看出，不同的符号是交替显示的。</p>
        <p>在同时运行多个线程时，运行结果不是唯一的，因为有很多不确定的因素。首先先执行哪一个线程就是不确定的，线程间交替也是不确定的。但是确定的是每一个线程都将启动，每一个线程都执行结束。</p>
        <h3>13.4  线程生命周期</h3>
        <p>线程是存在生命周期的。线程的生命周期分为五种不同的状态，分别是新建状态、准备状态、运行状态、等待/阻塞状态和死亡状态。在本节中就来对每一个状态进行讲解。</p>
        <h4>13.4.1  新建状态</h4>
        <p>当一个线程对象被创建后，线程就处于新建状态。在新建状态中的线程对象从严格意义上看还只是一个普通的对象，它还不是一个独立的线程。处于新建状态中的线程被调用start方法后就会进入准备状态。从新建状态中只能进入准备状态，并且不能从其他状态进行新建状态。新建状态是线程生命周期的第一个状态。</p>
        <h4>13.4.2  准备状态</h4>
        <p>处于新建状态中的线程被调用start方法就会进入准备状态。处于准备状态下的线程随时都可能被系统选择进入运行状态，从而执行线程。可能同时有多个线程处于准备状态，对于哪一个线程将进入运行状态是不确定的。线程从新建状态进入到准备状态后是不可能再进入新建状态的。在等待/阻塞状态中的线程被解除等待和阻塞后将不直接进入运行状态，而是首先进入准备状态，让系统来选择哪一个线程进入运行状态。</p>
        <h4>13.4.3  运行状态</h4>
        <p>处于准备状态中的线程一旦被系统选中，使线程获取了CPU时间，就会进入运行状态。在运行状态中将执行线程类run方法中的程序语句。线程进入运行状态后也不是一下执行结束的，线程在运行状态下随时都可能被调度程序调度回准备状态。在运行状态下还可以让线程进入到等待/阻塞状态。在通常的单核CPU中，在同一时刻只有一个线程处于运行状态的。在多核的CPU中，就可能两个线程或者更多的线程同时处于运行状态，这也是多核CPU运行速度快的原因。</p>
        <h4>13.4.4  等待/阻塞状态</h4>
        <p>在Java中定义了许多线程调度的方法，包括睡眠、阻塞、挂起和等待，这些方法将在后面的调度章节中讲解。使用这些方法都会将处于运行状态的线程调度到等待/阻塞状态。处于等待/阻塞状态的线程被解除后，不会立即回到运行状态，而是首先进入准备状态，等待系统的调度。</p>
        <h4>13.4.5  死亡状态</h4>
        <p>当线程中的run方法执行结束后，或者程序发生异常终止运行后，线程会进入死亡状态。处于死亡状态的线程不能再使用start方法启动线程，这在前面的学习中已经学到了这一点。但是这不代表处于死亡状态的线程不能再被使用，它也是可以再被使用的，只是将被作为普通的类来使用。</p>
        <p class="error">注意：线程生命周期的问题，有些同学们会觉得很容易的。线程生命周期的问题在后面的学习中会经常使用到，只有能充分了解线程的生命周期，才能更好地理解后面的内容。</p>
        <h3>13.5  线程的调度</h3>
        <p>通过系统自动调度，线程的执行顺序是没有保障的。在Java中定义了一些线程调度的方法，使用这些方法在一定程序上对线程进行调度，使用这些方法只是给线程一个建议，具体是否能够成功，也是没有保障的。线程调度的方法有几个，包括睡眠方法、设置优先级、让步方法等，在本节中就来学习这些方法的使用。</p>
        <h4>13.5.1  睡眠方法</h4>
        <p>当线程处于运行状态时，调用sleep睡眠方法将使线程从运行状态进入等待/阻塞状态，从而使程序停止运行。sleep睡眠方法是具有一个时间参数的，当经过这么长时间后，线程将进入准备状态，等待系统的调度。从而可以看出，当线程调用睡眠方法后，要想回到运行状态，需要的时间要比指定的睡眠时间长。</p>
        <p>sleep方法被重载，存在两种形式，sleep方法的基本语法格式如下所示。</p>
        <pre class="brush:java">public static void sleep(long millis) throws InterruptedException;
public static void sleep(long millis, int nanos) throws InterruptedException;
</pre>
        <p>使用这两个sleep方法都能使线程进入睡眠状态，mills参数表示线程睡眠的毫秒数，nanos参数表示线程睡眠的纳秒数。sleep方法是一个静态的方法，所以sleep方法不是依赖于某一个对象的，它的位置是比较随意的。当在线程中执行sleep方法，则该线程就进入睡眠状态。要想让某一个线程进入睡眠状态，并不是让该线程调用sleep方法，而只是让该线程执行sleep方法。sleep方法是可能发生捕获异常的，所以在使用sleep方法时必须进行异常处理。</p>
        <p class="error">注意：sleep方法只是给线程一个调度的建议，是否调度成功是不能确定的。在该程序中只有两个线程，所以运行结果出现交替显示的结果。当程序中存在多个线程时，运行结果就可以发生变化，甚至出现意外的结果。</p>
        <h4>13.5.2  线程优先级</h4>
        <p>在大部分的系统中，对进程的调度都是采用优先级的方式来进行的。在Java中对线程进行调度时，也是可以采用优先级来调度的。不同的线程可以具有不同的优先级，优先级高的线程就会占用更多的CPU资源和被执行概率。</p>
        <p>Java中的优先级是采用从1到10来表示的，数字越大表示优先级越高。如果没有为线程设置优先级，则线程的优先级为5，这也是线程的默认值。但是对于子线程来说，它的优先级是和其父线程优先级相同的。</p>
        <p>当需要对线程的优先级进行设置时，可以通过调用setPriority方法来设置。setPriority方法的语法格式如下所示。</p>
        <pre class="brush:java">public final void setPriority(int i);</pre>
        <p>其中参数i表示的就是优先级的等级数，它可以从1到10。除了可以使用数字来表示优先级，Java还在Thread类中定义了三个表示优先级的常量。MAX_PRIORITY表示线程的最高优先级，NORM_PRIORITY表示线程的默认优先级，MIN_PRIORITY表示线程的最低优先级。</p>
        <h4>13.5.3  yield让步方法</h4>
        <p>在Java中具有两种线程让步方法，先来介绍第一种yield让步方法。yield让步方法是让线程让出当前CPU，而将CPU让给哪一个线程是不确定的，由系统来进行选择。使用yield让步方法的线程将从运行状态进入到准备状态。</p>
        <p class="error">注意：yield让步操作是可能不成功的。因为在线程中使用yield方法，使该线程进入准备状态。但是系统是有可能再次选择该线程，使该线程进入运行状态的。</p>
        <p>yield让步方法的基本语法格式如下所示。</p>
        <pre class="brush:java">public static void yield();</pre>
        <p>可以看出yield让步方法是一个静态方法，所以该方法也是和对象无关的。当在正在运行的线程中运行该方法时，该线程将回到准备状态。</p>
        <h4>13.5.4  join让步方法</h4>
        <p>使用join让步方法，可以将当前线程的CPU资源让步给指定的线程。join让步方法的语法格式如下所示。</p>
        <pre class="brush:java">public final void join() throws InterruptedException;
public final void join(long mills) throws InterruptedException;
public final void join(long millis, int nanos) throws InterruptedException;
</pre>
        <p>join让步方法是具有三种形式的，没有参数表示指定的线程执行完成后再执行其他线程，参数表示在参数的时间内执行让步给的执行线程。join让步方法也是可能发生捕获异常的，所以在使用时要进行异常处理。</p>
        <h3>13.6  综合练习</h3>
        <p>1.判断下面程序是否能够正常运行。</p>
        <pre class="brush:java">public class LianXi1 extends Thread
{
	public void run()
	{
		for(int i = 0;i < 5;i++)
		{
			System.out.println(i);
		}
	}
	public static void main(String args[])
	{
		LianXi1 lx=new LianXi1();
		lx.run();
	}
}</pre>
        <p>2.判断下面的程序是否能够正常运行。</p>
        <pre class="brush:java">public class LianXi2 extends Thread
{
	public void run()
	{
		for(int i = 0;i < 5;i++)
		{
			Thread.sleep(100);
		}
	}
	public static void main(String args[])
	{
		LianXi1 lx=new LianXi1();
		lx.run();
	}
}</pre>
        <h3>13.7  小结</h3>
        <p>在本章中学习了Java中的多线程，首先对线程进行了简单的介绍，然后讲解如何定义、创建和运行多线程。接下来还讲解了线程的生命周期和对线程的调度。</p>
    </div>
</body>
</html>
