<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string name="c8_01">经过了前面学习，对面向对象有了一定的认识，下面开始学习面向对象的一个重要的概念——继承。在此基础上讨论重写、重载、重写与重载之间的区别，以及多态和如何灵活运用final、abstract等概念，因此学好这些概念是灵活运用多态的基石。通过本章的学习，读者应该能够完成如下几个目标。\n了解什么是继承和继承如何使用。\n掌握声明成员变量的修饰符。\n熟练掌握方法的重写和重载。\n了解枚举、反射和泛型等热门技术。\n
	</string>
	<string name="c8_02">8.1  什么是继承\n在日常生活中，经常遇到如下问题。有一辆自行车，自行车有颜色和型号大小之分，而公路赛车也有颜色和型号大小之分，公路赛车多了一项速度的优势。自行车有的东西公路赛车全都有，而公路赛车有的东西自行车不一定有，它们相同地方有很多。在Java中，对于这种情况下就采用继承来完成这个功能。\n【范例】通过示例来理解什么是继承。\n
	示例代码\n
	01	//这是一个类，表述的是一个自行车 \n
	02	public class bike\n
	03	{\n
	04	\t\tpublic String color; 	//自行车的颜色\n
	05	\t\tpublic int size; 		//自行车的大小,即型号\n
	06	}\n
	07	\n
	08	//这是一个类，表述的是一个公路赛类\n
	09	pubic class racing_cycle\n
	10	{\n
	11	\t\tpublic String color;  	//自行车的颜色\n
	12	\t\tpublic int size;      	//自行车的大小,即型号\n
	13	\t\tpublic String speed; 	//公路赛车的速度\n
	14	}\n
	下面就来使用继承来简化上面的程序。\n
	01	//这是一个类，表述的是一个自行车\n
	02	public class bike\n
	03	{\n
	04	\t\tpublic String color;	//自行车的颜色\n
	05	\t\tpublic int size; 			//自行车的大小，即型号\n
	06	}\n
	07	//这是一个类，表述的是一个公路赛车，它继承于自行车\n
	08	pubic class racing_cycle extends bike\n
	09	{\n
	10	\t\tpublic String speed;  		//公路赛车的速度\n
	11	}\n
	继承是为了让代码重复使用，提高效率，在此基础上衍生出更多的新类。继承是面向对象编程的特点，没有继承就不是面向对象编程，而是面向过程了。Java提供了单一继承，通过接口可以实现多重继承。本节要说明什么是继承，继承有那些特点。\n
	</string>
	<string name="c8_03">8.1.1  类的继承\n在Java中，被继承的类叫超类（superclass），继承超类的类叫子类（subclass）。因此，子类是超类的一个功能上的扩展，它继承了超类定义的所有属性和方法，并且添加了特有功能方法。\n首先举一个典型例子来说明继承有什么特点，然后再结合代码学习。\n有一对爷俩，爸爸和儿子，爸爸的眼睛是单眼皮，个子很高，头发很好，皮肤很黑，而儿子同样有他爸爸的一些特征，但是儿子的皮肤很白，双眼皮，戴眼镜，在外人看来他们是爷俩。儿子具有爸爸的所有特征，但是儿子的皮肤很白和戴眼睛这些是儿子自己所特有的，也是和爸爸不一样的地方。这个小例子正是日常生活里常见的。\n换到Java里，类与类之间的关系，可以看成倒置的金字塔，爸爸在上面，儿子在下面。爸爸可能有多个儿子，但是一个儿子只能有一个爸爸，这在日常生活里也是如此。\n
	\n本节学习了继承的使用，下面对其内容做如下总结。\n通过继承定义类，可以简化类的定义，让所需要的功能用相应的子类去定义和实现。\nJava是单继承的，子类可以有很多，父类只能有一个。上面的例子，如果加一个Friend类，Son只能继承自Father，要么继承Friend，不能同时继承Father和Friend。\nJava的继承是多层继承的，是一个类可以有很多子类，而子类下面又可以有很多子类。\n父类里的属性和方法可以让子类所有，父类里的属性和方法可以使子类同样拥有，而父类不能调用子类的方法和属性，子类的无参构造器默认是调用的父类的无参构造器。\n父类没有定义一个无参的构造器，那么编译器就默认生成一个无参的构造器，也可以在子类构造器里显示使用super方法调用父类构造器，super方法里写几个参数就可以表示调用的是父类的哪一个构造器。\n一般情况下，定义了一个有参的构造器，就应该定义一个无参的构造器\n
	</string>
	<string name="c8_04">8.1.2  继承的语法\n类的继承是通过Java保留的关键字extends来修饰的，通过extends的关键字表明前者具备后者的公共的成员变量和方法，在具备了所有的公共的成员变量和方法后，本身还能定义一些特有的成员变量和方法。基本语法如下所示。\nclass 类名 extends 父类名称\n【范例】下面是使用继承的程序。\n
	示例代码\n
	01	public class Father\n
	02	{\n
	03	\t\tpublic String name; 			//父亲的名字\n
	04	\t\tpublic int age; 				//父亲的年龄\n
	05	\t\tpublic String eye; 			//父亲眼睛的样子\n
	06	\t\tpublic String height; 			//父亲的身高\n
	07	\t\tpublic String cutis; 			//父亲的皮肤的颜色\n
	08	}\n
	09	\n
	10	public class Son extends Father 	//Son类继承与Father类\n
	11	{\n
	12	\t\tpublic String spectacle frame;  //这个属性是儿子所特有的 表示儿子是否带眼镜\n
	13	}\n
	</string>
	<string name="c8_05">8.2  修饰符\n修饰符是修饰的当前成员变量的访问限制和状态的。就好比一个眼镜，颜色是黑色的，这个黑色就修饰了这个眼镜，而眼镜的种类很多可以让不同的人群来使用，如近视眼镜就由有近视眼的人群来使用，别人来使用的话就不好了。\npublic String name;		//public 就是一个修饰符\n成员变量的继承是指B继承与A后，B能使用A的属性和方法，是受成员变量的修饰符决定的。在上一节的例子里的成员变量都是使用的默认修饰符，本小节将详细介绍修饰符是如何限制成员变量的继承的。主要有4个修饰符：public、private、default、protected，对其详细介绍将分为小节来进行。\n
	</string>
	<string name="c8_06">8.2.1  public：声明成员变量为公共类型\npublic表明被它修饰的成员变量为公共类型，那么这个成员变量在任何包里都能访问，包括子类也能访问到。\n
	</string>
	<string name="c8_07">8.2.2  private：声明成员变量为私有类型\nprivate表明被它修饰的成员变量为私有类型，表示除了本类外任何类都不能访问到这个成员变量，具有很好的保护性。\n
	</string>
	<string name="c8_08">8.2.3  default：声明成员变量为默认类型\n如果不给成员变量添加任何修饰符，就表示这个成员变量被修饰为default类型，在一个同包里的类或子类是能够访问的，相当于public类型，但是在不同包里的类或子类没有继承该成员变量，是访问不到它的。\n
	</string>
	<string name="c8_09">8.2.4  protected：声明成员变量为保护类型\nprotected表明被它修饰的成员变量为保护类型，在同一包里和public类型是一样的，也是能够访问到的，但是如果在不同包里的protected类型的成员变量就只能通过子类来访问，这个修饰符是区别于其他的修饰符的。\n\n（以后我们还会讲到有关虚类(virtual)和抽象类(abstract)的知识，读者可以先去了解一下。）\n
	</string>
	<string name="c8_10">8.3  成员变量的覆盖\n正如前面所举爸爸和儿子的例子，爸爸的眼睛是单眼皮，儿子的是双眼皮，不能说儿子没有继承爸爸的特性，只能说明儿子的特性把爸爸的覆盖了。成员变量的覆盖是子类里有和父类里相同的成员变量或方法，继承的关系，子类的成员变量将会使用，而父类的成员变量被保护起来。有时也因修饰符原因而变化。\n
	</string>
	<string name="c8_11">8.4  对象引用\n对象引用就好比一个人的名字，是一个代号。也是为了方便和容易记忆所用的。比如去商店里买水果，进门就说我要买水果，而售货员也不知道要买的是什么。在Java里定义了一个类，这个类里有很多的成员变量和方法，再给这个类起一个名字，这个名字就是这个对象的引用。\nbike b = new bike ();\n
	代码说明:\n
	bike b是创建Like类的一个对象应用，而这个b就相当于bike的名字。\n
	new bike ()相当于把bike这个类实例化了，真实存在与内存当中了。\n
	</string>
	<string name="c8_12">8.5  方法的重写和重载\n方法的重写和重载是体现继承特性的重要方面，理解了方法的重写和重载，可以为以后学习多态打下基础，本节重点学习重写和重载的用法和区别。\n
	</string>
	<string name="c8_13">8.5.1  方法重写的特点\n自行车的移动和公路赛车的移动都是靠外力来移动，二者是相同的。公路赛车继承了这一特点，但公路赛车的移动速度就不相同了，移动的快慢就是由它们各自移动特性不相同决定的，方法继承的特点和成员变量的覆盖很类似，但也有特殊情况，方法重写也可以叫方法的覆盖。关键字为override。\n
	</string>
	<string name="c8_14">8.5.2  方法重载的特点\n方法的重载就好比日常生活中人的名字，有大名也有小名，但这些名字都指的是这个人，不同点就是让这个人去做的事情可能不一样。\n这和Java里的重载很相似，关键字为overload。下面看一下重载的要求。\n重载的方法名称相同，但方法的参数列表不相同。如参数个数和参数类型等。\n重载的方法的返回值可以相同也可以不相同。\n代码演示：\n
	public String move(){};\n
	public String move(String name){};\n
	public void move(String name, int spend){};\n
	代码说明：\n虽然三种方法的名称是相同的，但这三种方法的的参数列表，即个数和类型，是不相同的。\n判断方法是否是重载，看参数列表是很重要的。\n什么是传递基本类型，所谓基本类型就是用于数学计算的那些类型。当有两个名称一样的方法时，根据传递数值的类型来匹配哪两个方法的参数列表是相同的。\n
	</string>
	<string name="c8_15">8.5.3  重写的返回类型\n方法有它的返回类型，而重写的方法也有返回类型，并有一些相应的限制。方法被重写后，返回的类型为基本类型时，重写方法的返回要必须一样，否则会出现错误。\n
	</string>
	<string name="c8_16">8.5.4  重写是基于继承的\n重写和重载的产生是基于继承的，如果没有发生继承就不会产生重写和重载了。举个例子来说，自行车通过外力可以移动，而公路赛车通过外力也可以移动，公路赛车继承了自行车的特性。也可以说成，公路赛车是自行车的一个升级版本。相当于一个参照点。\n
	</string>
	<string name="c8_17">8.5.5  静态方法是不能重写的\n静态方法就是被修饰为了static类型的方法，如果在类里声明具有唯一性，不是通过类的实例化而存在的，而是通过类的建立而存在，可以理解为用关键字new创建对象了，就是把这个对象实例化了。\n对本节的内容进行如下总结。\n父类的静态方法可以被子类的静态方法覆盖。\n父类的非静态方法不能被子类的静态方法覆盖。\n父类的静态方法不能被子类的非静态方法覆盖。\n覆盖是用于父类和子类之间。\n重写是用在同一个类中，有相同的方法名，但参数不一样。\n
	</string>
	<string name="c8_18">8.5.6  三者之间的关系\n重写的关键字是override，重载的关键字为overload，重写、重载、覆盖都是基于继承的关系。当继承的关系发生了，想用父类的方法就用super关键字来引用，如果想用新的方法了就重写下，来完成新的功能需要。对覆盖总结如下几点：\n覆盖的方法的参数列表必须要和被覆盖的方法的参数列表完全相同，才能达到覆盖的效果。\n覆盖的方法的返回值必须和被覆盖的方法的返回值一致。\n覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类。\n被覆盖的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行覆盖。\n对重载总结如下：\n使用重载时只能定义不同的参数列表。\n不能通过重载的方法的返回类型、访问权限和抛出的异常来进行方法的重载。\n对重写总结如下：\n重写的方法存在于父类中，也存在于子类中。\n重写的方法在运行期采用多态的形式。\n重写的方法不能比被重写的方法有更高的访问限制。\n重写的方法不能比被重写的方法有更多的异常。\n
	</string>
	<string name="c8_19">8.5.7  重写toString\ntoString()方法是Java里Object类的方法，很多类都重写了该方法。该方法返回对象的状态信息。下面是这个方法的原型：\n
public String toString()\n
	</string>
	<string name="c8_20">8.5.8  重写equals\n方法equals也是Object类的方法，很多类也进行了重写，一般重写equals方法是为了比较两个对象的内容是否相等。下面是这个方法的原型：\n
	public boolean equals（Object obj）\n
	{\n
	\t\treturn （this == obj）;		//这里比较的是两个对象的引用\n
	}\n
	</string>
	<string name="c8_21">8.6  final与继承的关系\nfinal关键字有最终、不变的意思，可以修饰成员变量，也可以修饰方法和类，通过final关键字的修饰可以改变其特性。\nfinal关键字修饰类时，说明其类不能有子类，也就是说该类不能被继承，该类的成员变量在这里将不起作用。\nfinal关键字修饰方法时，说明该方法不能被重写，因为类都不能继承了，方法就更不能重写了。\n类里可以含有final关键字修饰的方法。\nfinal关键字修饰的成员变量的对象引用不能修改。\nfinal关键字修饰的类里的方法默认被修饰为final\n
	</string>
	<string name="c8_22">8.7  abstract与继承的关系\nabstract关键字表示抽象的意思。所谓抽象，就好比在日常生活中人们设计的图纸，而这个图纸就好比是一个抽象的房子似的，需要把房子盖起来来实现这个图纸。在Java里抽象类里最少要含有一个抽象方法，让它的子类去实现这个抽象方法，抽象类里也可以定义一些方法。\n
	</string>
	<string name="c8_23">8.8  什么是多态\n这里来拿苹果和馒头来打个比方，苹果属于水果的一种，馒头属于面食的一种，而苹果和馒头都可以属于食物，一种物品有两种状态表现，这就是多态。\n
	</string>
	<string name="c8_24">对本节学习的内容总结如下：\nstatic修饰的方法和final修饰的方法是在编译期绑定的；而其他的方法是在运行期绑定，动态地判断是什么类型。\n多态是基于继承的，是类和接口相结合来实现的。\n
	</string>
	<string name="c8_25">8.9  什么是枚举类\n所谓枚举就好比日常生活中的星期一、星期二到星期天，是一组连续的数据。在Java里枚举类就是一组连续的基本类型的数值。下面举例如何创建枚举类型。\n
	public enum Grade\n
	{\n
	\t\tA, B, C, D, E, F \n
	};\n
	</string>
	<string name="c8_26">8.10  什么是反射机制\n在日常生活中，通过放大镜可以看清楚物体的内部结构。在Java中，反射机制就是起到放大镜的效果，可以通过类名，加载这个类，显示出这个类的方法等信息。\n
	</string>
	<string name="c8_27">8.11  什么是泛型\n在日常生活中，橡皮泥通过外力可以改变其形状，其形状是不固定的。在Java中，通过泛型可以给开发带来方便，通过参数的指定，可以改变其类型。\n使用泛型给程序员的代码编写带来了好处，也带来的缺点，了解它的好处和缺点，能给程序编写带来很多好处和便利。对泛型的好处总结如下：\n使用泛型，正如上面代码所示，能使代码看起来灵活；容易管理，不容易产生错误。\n使用泛型能使代码量减少，能产生很多公共代码。\n使用泛型在代码编译的时候能进行类型的检查并自动转换，使代码的运行效率得到提高。\n使用泛型在编译进行自动转换的时候出现了错误，会进行错误提示。\n使用泛型的时候参数只能是类的类型，不能是简单类型。\n使用泛型的时候参数可以有多个。\n使用泛型的时候参数也能继承别的类型。\n
	</string>
	<string name="c8_28">8.12  小结\n通过本小节的学习，读者可以了解继承的相关概念、用法和注意事项等。对修饰符所修饰的成员变量和方法要多多理解，对以后的编码有帮助。本章重点学习，方法和成员变量的重写、重载、覆盖这些概念。如果想了解更多的关于本章的内容，可以参考电子工业出版社出版的《深入浅出JDK 6.0》一书进行学习。\n
	</string>
</resources>
