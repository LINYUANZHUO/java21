<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string name="c18_01">在学习输出输入流之前，先来了解一下实际中的管道的问题。管道通常是可以双向流通的，Java中的流也是这样的，有输出流和输入流。管道是可以输送石油，也是可以输送水的，Java中的流也是可以输送不同的东西的，包括字节和字符等内容。Java中的输出输入流又称为IO流。通过本章的学习，读者应该能够完成如下几个目标。\n了解什么是IO流。\n掌握流的分类。\n熟练掌握流如何进行文件操作。\n
	</string>
	<string name="c18_02">18.1  IO流简介\n学习如何使用I/O流进行输入/输出操作之前，首先应当了解I/O流的基本原理与分类，这样才能恰当的运用各种I/O流进行不同的输入/输出操作。\n
	</string>
	<string name="c18_03">18.1.1  什么是IO流\n数据流是形象的概念，可以理解为是一种“数据的管道”。管道中流动的东西可以是基于字节，也可以是基于字符的等。就好像管道里面可以流动水，也可以流动石油一样，当程序需要读取数据的时候，就会开启一个通向数据源的管道，这个数据源可以是存放在硬盘中的文件，也可以是内存中的数据，或是网络上的数据。\nJava中的数据流分为2种，一种是字节流，另一种是字符流。这两种流主要由4个抽象类来表示：InputStream，OutputStream，Reader，Writer，输入输出各两种。其中InputStream和OutputStream表示字节流，Reader和Writer表示字符流，其他各种各样的流均是继承这4个抽象类而来的。\n
	</string>
	<string name="c18_04">18.1.2  节点流与处理流\n根据流功能层次的不同可以将其分为两类：节点流（Node Streams）与处理流（Processing Streams），下面列出了这两种流的异同。\n节点流一般用于直接从指定的位置进行读/写操作，例如磁盘文件、内存区域、网络连接等，其中一般只提供了一些基本的读写操作方法，功能比较单一。\n处理流往往是用于对其他输入/输出流进行封装，对内容进行过滤处理，其中一般提供了一些功能比较强大的读写方法。\n实际应用中，通常是将节点流与处理流二者结合起来使用。节点流直接与指定的源或目标相连，例如某个文件、某个网络连接等。而处理流则对节点流或其他处理流进一步进行封装，提供更丰富的输入/输出操作能力，例如缓冲、按字符串行读写等。\n
	</string>
	<string name="c18_05">18.1.3  字节流与字符流\n根据流处理数据类型的不同也可以以将其分为两类：字节流与字符流，下面列出了这两种流的不同之处。\n字节流以字节为基本单位来处理数据的输入/输出，一般都用于对二进制数据的读写，例如声音、图象等数据。\n字符流以字符为基本单位来处理数据的输入和输出，一般都用于对文本类型数据的读写，例如文本文件、网络中发送的文本信息等。\n表列出了Java I/O中字节流与字符流的四个抽象基类，Java I/O中的其他字节流与字符流都派生自这四个抽象基类。\n
	</string>
	<string name="c18_06">18.1.4  抽象基类\n字节流和字符流的抽象基类包括InputStream类、OutputStream类、Reader类和Writer类组成，在后面将要讲到的流类都是继承这几个抽象基类的。\n1. InputStream类:InputStream类是一个输入流，同样也是一个字节流。InputStream类是表示字节输入流的所有类的超类。其中定义了一些基本的读取字节数据流的方法，由其子类继承并扩展。\npublic int available() throws IOException获取可以从此输入流读取（或跳过）的字节数\npublic void close() throws IOException关闭输入流，同时释放系统资源\npublic void mark(int readlimit)在输入流中标记位置，参数readlimit为位置参数\npublic boolean markSupported()用于测试该输入流是否支持mark和reset方法\npublic abstract int read() throws IOException从输入流中读取下一个数据字节\npublic int read(byte[] b) throws IOException从输入流中读取字节数据，并存入字节数组b中\npublic int read(byte[] b,int off,int len) throws IOException从输入流中读取len个数据字节，并存入字节数组b中\npublic void reset() throws IOException将此流重新定位到最后一次调用mark方法时所处的位置\npublic long skip(long n) throws IOException跳过并且放弃输入流中的n个字节数据\n使用InputStream类是可能发生IOException异常的，所以在使用时是要进行异常处理的。\n
	</string>
	<string name="c18_07">OutputStream类\nOutputStream类是一个输出流，同样也是一个字节流。OutputStream类是表示输出字节流的所有类的超类。输出流接收输出字节并将这些字节发送到某个接收器。 \npublic void close() throws IOException关闭输出流，同时释放系统资源\npublic void flush() throws IOException刷新输出流，同时输出所有缓冲的输出字节\npublic void write(byte[] b) throws IOException将字节数组b中的b.length个字节数据输入到输出流\npublic void write(byte[] b,int off,int len) throws IOException将字节数组b中的len个字节数据（从偏移量off开始）输入到输出流\npublic abstract void write(int b) throws IOException将指定的字节输入到输出流\n同样使用InputStream类是可能发生IOException异常的，所以在使用时是要进行异常处理的。\n
	</string>
	<string name="c18_08">Reader类 \nReader类是一个输入流，同样也是一个字符流。Reader类是所有输入字符流的超类，也就是说所有的输入字符流都派生自Reader类，其中提供了很多关于字符流输入操作的方法， \npublic abstract int read()throws IOException读取单个字符，返回值的低16比特存放读取字符的编码（0～65535），高16比特忽略，如果因为已经到达流末尾而没有可读的字符，则返回值-1。往往都会将此方法的返回值强制类型转换成char类型\npublic int read(char[] cbuf)throws IOException从输入流中读取一定数量的字符，并将其存储在缓冲区字符数组cbuf中，以整数形式返回实际读取的字符数。若流中实际可读的字符数小于数组cbuf的长度，则返回值会小于数组cbuf的长度，否则返回值等于数组cbuf的长度\npublic abstract int read(char[] cbuf,int off,int len)throws IOException将输入流中最多len个字符读入字符数组cbuf，将读取的第一个字符存储在元素cbuf[off]中，下一个存储在cbuf[off+1]中，依次类推，方法的返回值为实际读取的字符数。若流中实际可读的字符数小于len，则返回值会小于len，否则返回值等于len\npublic long skip(long n)throws IOException跳过此输入流中的指定数量的字符，参数n为指定的数量，返回值为实际跳过的字符数\npublic boolean ready()throws IOException判断此字符输入流是否准备好被读，若是则返回true，否则返回false\npublic void close()throws IOException关闭此输入流并释放与该流关联的所有系统资源\npublic void mark(int readAheadLimit)throws IOException在此输入流中标记当前的位置，参数readAheadLimit指出从此标记位置开始此流可以记忆的最大字符数，未来调用reset方法可以回到标记处重新读取字符。没有使用mark方法设置标记的流是不能回到某处再次读取的\npublic void reset() throws IOException将此流重新定位到最后一次对此流调用mark方法时的位置public boolean markSupported()测试此输入流是否支持mark和reset方法，支持则返回true，否则返回false\npublic void mark(int readAheadLimit)throws IOException在此输入流中标记当前的位置，参数readAheadLimit指出从此标记位置开始此流可以记忆的最大字符数，未来调用reset方法可以回到标记处重新读取字符。没有使用mark方法设置标记的流是不能回到某处再次读取的\npublic void reset() throws IOException将此流重新定位到最后一次对此流调用mark方法时的位置public boolean markSupported()测试此输入流是否支持mark和reset方法，支持则返回true，否则返回false\n同样使用Reader类是可能发生IOException异常的，所以在使用时是要进行异常处理的。\n
	</string>
	<string name="c18_09">Writer类 \nWriter类是一个输出流，同样也是一个字符流。Writer类是所有输出字符流的超类，也就是说所有的输出字符流都派生自Writer类，其中提供了很多关于字符流输出操作的方法， \npublic void write(int c)throws IOException将指定的字符写入此输出流，参数c表示要写入的字符。要注意的是，c的低16个比特被作为一个字符写入流，而高16个比特被忽略\npublic void write(char[] cbuf) throws IOException将指定字符数组cbuf的内容写入输入流\npublic abstract void write(char[] cbuf,int off,int len)throws IOException将指定字符数组cbuf中从偏移量off开始的len个字符写入此输出流\npublic void write(String str)throws IOException向流中写入指定字符串str的各个字符\npublic void write(String str,int off,int len)throws IOException将指定字符串str中从偏移量off开始的len个字符写入此输出流\npublic void flush()throws IOException刷新此输出流并强制写出所有缓冲中的输出字符\npublic void close()throws IOException关闭此输出流并释放与此流有关的所有系统资源\n同样使用Reader类是可能发生IOException异常的，所以在使用时是要进行异常处理的。字节流与字符流提供的方法很相似的。它们的不同主要体现在操作的基本单位不同，一个是以字节为基本单位，另一个是以字符为基本单位。\n注意：字节流和字符流的不同主要体现在操作的基本单位不同，一个是以字节为基本单位，另一个是以字符为基本单位。\n
	</string>
	<string name="c18_10">18.2  使用流进行文件操作\n使用流来进行文件操作是流应用中最常见的应用之一。使用流能够读取文件内容，同样也能够写入文件内容。进行文件操作的类包括File、FileInputStream、FileOutputStream、FileReader、FileWriter等几个类。\n
	</string>
	<string name="c18_11">18.2.1  使用File类进行文件与目录操作\nJava中专门提供了一个表示目录与文件的类——java.io.File，通过其可以获取文件、目录的信息，对文件、目录进行管理。File类一共提供了四个构造器，表列出了其中常用的三个。\n在File类中最常用的是第一个构造函数。使用构造函数public File(String pathname)创建一个文件对象。其中，如果pathname是实际存在的路径，则该File对象表示的是目录；如果pathname是存在的文件名，则该File对象表示的是文件。\npublic File(String pathname)通过指定的路径名字符串pathname创建一个File对象，如果给定字符串是空字符串，那么创建的File对象将不代表任何文件或目录\npublic File(String parent,String child)根据指定的父路径名字符串parent以及子路径字符串child创建一个File对象。若parent为null，则与单字符串参数构造器效果一样，否则parent将用于表示目录，而child则表示该目录下的子目录或文件\npublic File(File parent,String child)根据指定的父File对象parent及子路径字符串child创建一个File对象。若parent为null，则与单字符串参数构造器效果一样，否则parent将用于表示目录，而child则表示该目录下的子目录或文件\n
	</string>
	<string name="c18_12">18.2.2  FileInputStream类与FileOutputStream类\nFileInputStream类是InputStream的子类。FileInputStream类主要用于从文件系统中的某个文件中获取输入字节。FileOutputStream类是OutputStream的子类，FileOutputStream主要是用于将数据以字节流写入目标文件的输出流。表为FileInputStream中的方法声明及其使用描述。\nFileInputStream类从文件系统中的某个文件中获取输入字节。主要用于读取诸如图像数据之类的原始字节流。要读取字符流，可以考虑使用FileReader。 \nintavailable()返回可以从该文件输入流中读取的字节数\nclose()关闭文件输入流，同时释放系统资源\nfinalize()确认文件输入流不在被引用的状态，并可以调用close方法\ngetChannel()返回与该文件输入流有关的FileChannel对象\ngetFD()返回连接到文件系统（正被该FileInputStream使用）中实际文件的FileDescriptor对象\nread()从该输入流中读取一个数据字节，并以int类型返回read(byte[] b)读取输入流中b.length个字节的数据，并存入字节数组b中\nread(byte[] b, int off, int len)读取输入流中从偏移量off开始的len个字节的数据，并存入字节数组b中\nskip(long n)跳过输入流中的数据，同时丢弃n个字节的数据\n与FileInputStream类相对，FileOutputStream类用于将数据写入File或FileDescriptor的输出流。主要用于写入诸如图像数据之类的原始字节的流。要写入字符流，可以考虑使用FileWriter。\nfinalize()断开到文件的连接，确认该文件输出流不处在被引用状态，并可以调用close方法\nChannelgetChannel()返回与该文件输出流有关的FileChannel对象\ngetFD()返回与该流有关的文件描述符FileDescriptor对象\nwrite(byte[] b)将b.length个字节的数据从指定字节数组写入到该文件输出流中\nwrite(byte[] b, int off, int len)将指定字节数组中的部分数据（从偏移量off开始的len个字节）写入到该文件输出流\nwrite(int b)将指定字节b写入到该文件输出流\n
	</string>
	<string name="c18_13">18.2.3  FileReader类与FileWriter类\nFileReader与FileWriter和FileInputStream与FileOutputStream类似，所不同的是它们是针对字符进行操作，而不是字节。这两个类的间接父类是字符流Reader和Writer。其中，FileWriter是用于写入字符文件的便捷类。FileReader是用于读取字符文件的便捷类。在FileReader类及FileWriter类中未自定义方法，继承了其父类及间接父类中的方法。\n
	</string>
	<string name="c18_14">18.3  小结\n在本章中主要对Java中的流进行了详细的讲解，同时也讲解了如何使用流进行文件操作。进行文件操作是流的最重要作用之一，这里对其进行详细的讲解。\n
	</string>
</resources>